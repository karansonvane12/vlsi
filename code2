library IEEE; 
use IEEE.STD_LOGIC_1164.ALL; 
use IEEE.NUMERIC_STD.ALL; 
entity fifo is 
 port ( 
 clk : in std_logic; 
 rst : in std_logic; 
 enw : in std_logic; -- write enable 
 enr : in std_logic; -- read enable 
 datain : in std_logic_vector(7 downto 0); 
 dataout : out std_logic_vector(7 downto 0); 
 empty : out std_logic; 
 full : out std_logic 
 ); 
end fifo; 
architecture Behavioral of fifo is 
 constant DEPTH : integer := 16; 
 type memory_type is array (0 to DEPTH-1) of std_logic_vector(7 downto 0); 
 signal memory : memory_type := (others => (others => '0')); 
 signal readptr, writeptr : unsigned(3 downto 0) := (others => '0'); 
 signal dataout_reg : std_logic_vector(7 downto 0); 
 signal full_reg, empty_reg : std_logic := '1'; 
begin 
 dataout <= dataout_reg; 
 full <= full_reg; 
 empty <= empty_reg; 
 process(clk, rst) 
 begin 
 if rst = '1' then 
 readptr <= (others => '0');
writeptr <= (others => '0'); 
 full_reg <= '0'; 
 empty_reg <= '1'; 
 dataout_reg <= (others => '0'); 
 elsif rising_edge(clk) then 
 -- Write operation 
 if (enw = '1' and full_reg = '0') then 
 memory(to_integer(writeptr)) <= datain; 
 writeptr <= writeptr + 1; 
 end if; 
 -- Read operation 
 if (enr = '1' and empty_reg = '0') then 
 dataout_reg <= memory(to_integer(readptr)); 
 readptr <= readptr + 1; 
 end if; 
 -- Update flags 
 if (writeptr + 1 = readptr) then 
 full_reg <= '1'; 
 else 
 full_reg <= '0'; 
 end if; 
 if (readptr = writeptr) then 
 empty_reg <= '1'; 
 else 
 empty_reg <= '0'; 
 end if; 
 end if; 
 end process; 
end Behavioral;
